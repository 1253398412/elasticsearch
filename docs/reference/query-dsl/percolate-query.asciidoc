[[query-dsl-percolate-query]]
=== Percolate query
++++
<titleabbrev>Percolate</titleabbrev>
++++

Returns, or percolates, stored queries based on documents those queries would
match.

The `percolate` query acts as a reverse search. First, you index stored queries
using a <<percolator,`percolator`>> field. Then you can use a `percolate` query
to return those stored queries based on documents they would match.


[[percolate-query-ex-requests]]
==== Example request

[[percolate-query-index-setup]]
===== Index setup
To use the `percolate` query, your index must include a
<<percolator,`percolator`>> field. To see how you can set up an index for this
query, try the following example.

Create an index with the following field mapping:

* `stored-query`, a <<percolator,`percolator`>> field used to store queries
* `message`, a <<text,`text`>> field


[source,js]
--------------------------------------------------
PUT /my-index
{
    "mappings": {
        "properties": {
             "stored-query": {
                 "type": "percolator"
             },
              "message": {
                 "type": "text"
             }
        }
    }
}
--------------------------------------------------
// CONSOLE

Index a stored query.

[source,js]
--------------------------------------------------
PUT /my-index/_doc/1?refresh
{
    "stored-query" : {
        "match" : {
            "message" : "bonsai tree"
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

TIP: This example uses one index, `my-index`, for both stored queries and
documents. This can work well if your index contains only a few stored queries.
For heavier usage, we recommend storing queries and documents in separate
indices. See <<how-it-works>> for more details.

[[percolate-query-ex-query]]
===== Example query

Run the following `percolate` search to return stored queries that would match
the provided `document`.

[source,js]
--------------------------------------------------
GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field" : "stored-query",
            "document" : {
                "message" : "A new bonsai tree in the office"
            }
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

The search returns the following response.

[source,js]
--------------------------------------------------
{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.26152915,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1", <1>
        "_score": 0.26152915,
        "_source": {
          "stored-query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0] <2>
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 13,/"took": "$body.took",/]

<1> The query with id `1` matches our document.
<2> The `_percolator_document_slot` field indicates which document has matched with this query.
    Useful when percolating multiple documents simultaneously.



[[percolate-top-level-params]]
==== Top-level parameters for `percolate`
`field`::
(Required, string) <<percolator,`percolator`>> field used to store queries.

[[percolate-query-document-param]]
`document`::
+
--
(Optional, <<docs-index_,document object>>) Document used to return, or
percolate, matching queries.

To use multiple documents, use the
<<percolate-query-documents-param,`documents`>> parameter.

To use an existing document, use <<percolate-document-lookup-params,document
lookup parameters>>. See <<percolate-query-existing-document>> for an
example.
--

[[percolate-query-documents-param]]
`documents`::
(Optional, array of <<docs-index_,document objects>>) Array of documents used to
find matching stored queries. See <<percolate-query-multi-docs>> for an example.

`name`::
(Optional, string) Suffix used with the `_percolator_document_slot` meta-field
if multiple `percolate` queries are used. See <<multiple-percolate-queries>>
for an example.

`document_type`::
(Optional, string) <<mapping-type-field,Type>> of the document used to find
matching queries. This parameter is deprecated and will be removed in 8.0. See
<<removal-of-types>>.


[[percolate-query-notes]]
==== Notes

[[percolate-query-filter-context]]
===== Percolate in a filter context

In case you are not interested in the score, better performance can be expected by wrapping
the percolator query in a `bool` query's filter clause or in a `constant_score` query:

[source,js]
--------------------------------------------------
GET /my-index/_search
{
    "query" : {
        "constant_score": {
            "filter": {
                "percolate" : {
                    "field" : "stored-query",
                    "document" : {
                        "message" : "A new bonsai tree in the office"
                    }
                }
            }
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

At index time terms are extracted from the percolator query and the percolator
can often determine whether a query matches just by looking at those extracted
terms. However, computing scores requires to deserialize each matching query
and run it against the percolated document, which is a much more expensive
operation. Hence if computing scores is not required the `percolate` query
should be wrapped in a `constant_score` query or a `bool` query's filter clause.

Note that the `percolate` query never gets cached by the query cache.

[[percolate-query-multi-docs]]
===== Percolate multiple documents

The `percolate` query can match multiple documents simultaneously with the indexed percolator queries.
Percolating multiple documents in a single request can improve performance as queries only need to be parsed and
matched once instead of multiple times.

The `_percolator_document_slot` field that is being returned with each matched percolator query is important when percolating
multiple documents simultaneously. It indicates which documents matched with a particular percolator query. The numbers
correlate with the slot in the `documents` array specified in the `percolate` query.

[source,js]
--------------------------------------------------
GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field" : "stored-query",
            "documents" : [ <1>
                {
                    "message" : "bonsai tree"
                },
                {
                    "message" : "new tree"
                },
                {
                    "message" : "the office"
                },
                {
                    "message" : "office tree"
                }
            ]
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> The documents array contains 4 documents that are going to be percolated at the same time.

[source,js]
--------------------------------------------------
{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.7093853,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.7093853,
        "_source": {
          "stored-query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0, 1, 3] <1>
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 13,/"took": "$body.took",/]

<1> The `_percolator_document_slot` indicates that the first, second and last documents specified in the `percolate` query
    are matching with this query.

[[percolate-query-existing-document]]
===== Percolate an Existing Document

In order to percolate a newly indexed document, the `percolate` query can be used. Based on the response
from an index request, the `_id` and other meta information can be used to immediately percolate the newly added
document.

[[percolate-query-existing-document-ex]]
====== Example 

Based on the previous example.

Index the document we want to percolate:

[source,js]
--------------------------------------------------
PUT /my-index/_doc/2
{
  "message" : "A new bonsai tree in the office"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]
Index response:

[source,js]
--------------------------------------------------
{
  "_index": "my-index",
  "_type": "_doc",
  "_id": "2",
  "_version": 1,
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "result": "created",
  "_seq_no" : 1,
  "_primary_term" : 1
}
--------------------------------------------------
// TESTRESPONSE

Percolating an existing document, using the index response as basis to build to new search request:

[source,js]
--------------------------------------------------
GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field": "stored-query",
            "index" : "my-index",
            "id" : "2",
            "version" : 1 <1>
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> The version is optional, but useful in certain cases. We can ensure that we are trying to percolate
the document we just have indexed. A change may be made after we have indexed, and if that is the
case the search request would fail with a version conflict error.

The search response returned is identical as in the previous example.

[[percolate-document-lookup-params]]
====== Document lookup parameters
To fetch an existing document, use the following document lookup parameters
in place of the <<percolate-query-document-param,`document`>> parameter.

`index`::
(Required, string) Name of the index from which to fetch a document.

`id`::
(Required, string) <<mapping-id-field,ID>> of the document to fetch.

`preference`::
(Optional, string) <<search-request-preference,Preference>> of shard copies from
which to fetch the document.

`routing`::
(Optional, string) Custom <<mapping-routing-field, routing value>>
of the document to fetch.

`type`::
(Optional, string) <<mapping-type-field,Type>> of the document to fetch. This
parameter is deprecated and will be removed in 8.0. See <<removal-of-types>>.

`version`::
(Optional, string) <<search-request-version,Version>> of the document to fetch.

[[percolate-query-highlighting]]
===== Percolate query and highlighting

The `percolate` query is handled in a special way when it comes to highlighting. The queries hits are used
to highlight the document that is provided in the `percolate` query. Whereas with regular highlighting the query in
the search request is used to highlight the hits.

[[percolate-query-highlighting-ex]]
====== Example

This example is based on the mapping of the first example.

Save a query:

[source,js]
--------------------------------------------------
PUT /my-index/_doc/3?refresh
{
    "stored-query" : {
        "match" : {
            "message" : "brown fox"
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

Save another query:

[source,js]
--------------------------------------------------
PUT /my-index/_doc/4?refresh
{
    "stored-query" : {
        "match" : {
            "message" : "lazy dog"
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

Execute a search request with the `percolate` query and highlighting enabled:

[source,js]
--------------------------------------------------
GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field": "stored-query",
            "document" : {
                "message" : "The quick brown fox jumps over the lazy dog"
            }
        }
    },
    "highlight": {
      "fields": {
        "message": {}
      }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

This will yield the following response.

[source,js]
--------------------------------------------------
{
  "took": 7,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 2,
        "relation": "eq"
    },
    "max_score": 0.26152915,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "3",
        "_score": 0.26152915,
        "_source": {
          "stored-query": {
            "match": {
              "message": "brown fox"
            }
          }
        },
        "highlight": {
          "message": [
            "The quick <em>brown</em> <em>fox</em> jumps over the lazy dog" <1>
          ]
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      },
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "4",
        "_score": 0.26152915,
        "_source": {
          "stored-query": {
            "match": {
              "message": "lazy dog"
            }
          }
        },
        "highlight": {
          "message": [
            "The quick brown fox jumps over the <em>lazy</em> <em>dog</em>" <1>
          ]
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 7,/"took": "$body.took",/]

<1> The terms from each query have been highlighted in the document.

Instead of the query in the search request highlighting the percolator hits, the percolator queries are highlighting
the document defined in the `percolate` query.

When percolating multiple documents at the same time like the request below then the highlight response is different:

[source,js]
--------------------------------------------------
GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field": "stored-query",
            "documents" : [
                {
                    "message" : "bonsai tree"
                },
                {
                    "message" : "new tree"
                },
                {
                    "message" : "the office"
                },
                {
                    "message" : "office tree"
                }
            ]
        }
    },
    "highlight": {
      "fields": {
        "message": {}
      }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

The slightly different response:

[source,js]
--------------------------------------------------
{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.7093853,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.7093853,
        "_source": {
          "stored-query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0, 1, 3]
        },
        "highlight" : { <1>
          "0_message" : [
              "<em>bonsai</em> <em>tree</em>"
          ],
          "3_message" : [
              "office <em>tree</em>"
          ],
          "1_message" : [
              "new <em>tree</em>"
          ]
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 13,/"took": "$body.took",/]

<1> The highlight fields have been prefixed with the document slot they belong to,
    in order to know which highlight field belongs to what document.

[[multiple-percolate-queries]]
===== Use multiple percolate queries

It is possible to specify multiple `percolate` queries in a single search request:

[source,js]
--------------------------------------------------
GET /my-index/_search
{
    "query" : {
        "bool" : {
            "should" : [
                {
                    "percolate" : {
                        "field" : "stored-query",
                        "document" : {
                            "message" : "bonsai tree"
                        },
                        "name": "query1" <1>
                    }
                },
                {
                    "percolate" : {
                        "field" : "stored-query",
                        "document" : {
                            "message" : "tulip flower"
                        },
                        "name": "query2" <1>
                    }
                }
            ]
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> The `name` parameter will be used to identify which percolator document slots belong to what `percolate` query.

The `_percolator_document_slot` field name will be suffixed with what is specified in the `_name` parameter.
If that isn't specified then the `field` parameter will be used, which in this case will result in ambiguity.

The above search request returns a response similar to this:

[source,js]
--------------------------------------------------
{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.26152915,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.26152915,
        "_source": {
          "stored-query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot_query1" : [0] <1>
        }
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 13,/"took": "$body.took",/]

<1> The `_percolator_document_slot_query1` percolator slot field indicates that these matched slots are from the `percolate`
    query with `_name` parameter set to `query1`.

[[how-it-works]]
===== How the `percolate` query works

When indexing a document into an index that has the <<percolator,percolator field type>> mapping configured, the query
part of the document gets parsed into a Lucene query and is stored into the Lucene index. A binary representation
of the query gets stored, but also the query's terms are analyzed and stored into an indexed field.

At search time, the document specified in the request gets parsed into a Lucene document and is stored in a in-memory
temporary Lucene index. This in-memory index can just hold this one document and it is optimized for that. After this
a special query is built based on the terms in the in-memory index that select candidate percolator queries based on
their indexed query terms. These queries are then evaluated by the in-memory index if they actually match.

The selecting of candidate percolator queries matches is an important performance optimization during the execution
of the `percolate` query as it can significantly reduce the number of candidate matches the in-memory index needs to
evaluate. The reason the `percolate` query can do this is because during indexing of the percolator queries the query
terms are being extracted and indexed with the percolator query. Unfortunately the percolator cannot extract terms from
all queries (for example the `wildcard` or `geo_shape` query) and as a result of that in certain cases the percolator
can't do the selecting optimization (for example if an unsupported query is defined in a required clause of a boolean query
or the unsupported query is the only query in the percolator document).  These queries are marked by the percolator and
can be found by running the following search:


[source,js]
---------------------------------------------------
GET /_search
{
  "query": {
    "term" : {
      "query.extraction_result" : "failed"
    }
  }
}
---------------------------------------------------
// CONSOLE

NOTE: The above example assumes that there is a `stored-query` field of type
`percolator` in the mappings.

Given the design of percolation, it often makes sense to use separate indices for the percolate queries and documents
being percolated, as opposed to a single index as we do in examples. There are a few benefits to this approach:

- Because percolate queries contain a different set of fields from the percolated documents, using two separate indices
allows for fields to be stored in a denser, more efficient way.
- Percolate queries do not scale in the same way as other queries, so percolation performance may benefit from using
a different index configuration, like the number of primary shards.
